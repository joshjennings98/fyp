// NEW SHIT

double const pi = 3.14159265358979323846;
double const two_pi = 2.0 * pi;
double const half_pi = 0.5 * pi;

double cosineCalc(double x)
{{
    const double c1= 0.99999999999999806767;
    const double c2=-0.4999999999998996568;
    const double c3= 0.04166666666581174292;
    const double c4=-0.001388888886113613522;
    const double c5= 0.000024801582876042427;
    const double c6=-0.0000002755693576863181;
    const double c7= 0.0000000020858327958707;
    const double c8=-0.000000000011080716368;

    double x2;

    x2 = x * x; // x**2

    return c1 + x2*(c2 + x2*(c3 + x2*(c4 + x2*(c5 + x2*(c6 + x2*(c7 + x2*c8))))));
}}

// Driver for cosine function, simplifies maths
double cosine(double x)
{{
    //return cos(x);
    int quad; // quadrant

    
    // float modulo to get rid of x > 2pi
    while (x > two_pi)
        x -= two_pi;

    // cos -x = cos x
    if (x < 0)
        x = -x;
    

    quad = int(x/half_pi);
    switch (quad) {{
        case 0:
            return cosineCalc(x);
        case 1:
            return -cosineCalc(pi-x);
        case 2:
            return -cosineCalc(x-pi);
        case 3:
            return cosineCalc(two_pi-x);
    }}
}}

// sine is just cosine shifted by half pi
double sine(double x)
{{
    return cosine(half_pi - x);
}}

double grng(uint32_t &state)
{{
	double mu = 0, sigma = 1;
	static const double epsilon = std::numeric_limits<double>::min();
	// static const double two_pi = 2.0*3.14159265358979323846;

	thread_local double z1;
	thread_local bool generate;
	generate = !generate;

	if (!generate)
	   return z1 * sigma + mu;

	double u1, u2;

    do
    {{
        u1 = (double)urng(state) / 4294967295.0f;
        u2 = (double)urng(state) / 4294967295.0f;
    }}
    while (u1 <= epsilon);

	double z0;
	z0 = sqrt(-2.0 * log(u1)) * cosine(two_pi * u2);
	z1 = sqrt(-2.0 * log(u1)) * sine(two_pi * u2);

	return z0 * sigma + mu;
}}